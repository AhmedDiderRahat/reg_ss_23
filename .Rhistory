exam <- factor(exam,
levels=c(TRUE, FALSE),
labels = c("success", "failure"))
print(exam)
table(exam)
## New and relabeled Levels
exam <- c(TRUE, TRUE, FALSE, TRUE, FALSE)
exam <- factor(exam,
levels=c(TRUE, FALSE),
labels = c("success", "failure"))\
exam <- factor(exam,
levels=c(TRUE, FALSE),
labels = c("success", "failure"))
print(exam)
table(exam)
x <- data.frame(eggs = 1:4, ham = c(TRUE, TRUE, FALSE, FALSE))
print(x)
print(nrow(x))
print(ncol(x)) # number of column
print(dim(x)) # total dimension
x <- data.frame(my_num = 1:4,
my_char = "a",
my_logic = c(TRUE, FALSE, FALSE, TRUE))
print(x)
str(x)
x <- list(1, "a", TRUE)
print(typeof(x))
print(x)
x <- list(1, 2, "a", TRUE)
print(typeof(x))
print(x)
x <- list(a = 1,
b = list(1, 2),
c = data.frame(x = 1:2))
print(x)
str(x)
x <- 5:15
x
# Preparations
rm(list = ls(all.names = TRUE))
x <- 5:15
x
quantile(x, probs = 0.5)
quantile(x, probs = 0.1)
quantile(x, probs = c(0.1, 0.11))
0.11*11
quantile(x)
# Deciles
quantile(x, probs = 1:9/10)
# Percentiles
quantile(x, prob = 1:99/100)
# BMI
bmi <- c(18.13, 18.53, 20.75, 21.86, 22.65, 22.93, 22.95, 23.75, 23.82, 24.01, 24.68, 24.89, 25.25,
25.75, 25.85, 25.9, 26.11, 26.73, 27.2, 27.67, 27.94, 28.19, 29.29, 31.22, 32.37)
boxplot(bmi)
# Preparations
rm(list = ls(all.names = TRUE))
sales <- c(1585, 1819, 1647, 1496, 921, 1278, 1810, 1987, 1612, 1413)
price <- c(12.50, 10.00, 9.95, 11.50, 12.00, 10.00, 8.00, 9.00, 9.50, 12.50)
# making data frame
df <- data.frame(sales, price)
# print summary
str(df)
# Solution (a):
plot(df)
# Solution (b):
lr_model <- lm(df$price ~ df$sales)
summary(lr_model)$coefficient
abline(lr_model, col='seagreen', lwd = 2)
# Solution (c):
r_xy <- cor(df$sales, df$price); r_xy # -0.6172626
b1_hat <- -0.003133623
sx <- sd(df$sales); sx
sy <- sd(df$price); sy
new_data <- b1_hat * (sx / sy); new_data # -0.6172626
# reset the plotting window again
par(mfrow = c(1, 1))
simple.lm <- function(x, y){
# mean of x
mx <- mean(x)
#mean of y
my <- mean(y)
# variance of x, and y
sx2 <- var(x)
sy2 <- var(y)
# Co-variance calculation
sxy <- cov(x, y)
# regression coefficient calculation
b1_hat  <- sxy / sx2
b0_hat <- my - (mx * b1_hat)
return ( list(b0_hat = b0_hat, b1_hat = b1_hat))
}
# read the file
rent <- read.csv('Dataset/MunichRent2003.csv')
getwd()
setwd("C:\Users\DELL\Desktop\Summer 2023\RegDS23\reg_ss_23")
setwd("C:/Users/DELL/Desktop/Summer 2023/RegDS23/reg_ss_23")
getwd()
# read the file
rent <- read.csv('Dataset/MunichRent2003.csv')
# view data frame
View(rent)
# attached columns
attach(rent)
# get the regression coefficient
reg_coeff <- simple.lm(x = living.space, y = netrent)
# print the value of the coefficient
str(reg_coeff)
# plot the point cloud
plot(netrent ~ living.space)
# draw the regression line
abline(reg_coeff$b0_hat, reg_coeff$b1_hat, col = 'seagreen', lwd=3)
R2 <- function(x, y, b0, b1){
y_hat <- b0 + (b1 * x)
sy_hat2 <- var(y_hat)
sy2 <- var(y)
#return(y_hat)
return(sy_hat2 / sy2)
}
# my function output
calculated_r2 <- R2(living.space, netrent, reg_coeff$b0_hat, reg_coeff$b1_hat); calculated_r2
# linear modeling
ll_reg <- lm(netrent ~ living.space)
summary(ll_reg)$r.squared
# initialize c
C <- c(2, 3, 1, 5, 7)
# initialize X
X <- seq(-5, 5, by=0.1); X
# the poly_eval function calculate all the respective value of each X value
poly_eval <- function(X, C){
# init Y with empty vector
Y <- c()
# iterate over all X
for (x in X){
# set y, and i=0
y <- 0
i <- 0
# iterate for all value of C
for (c in C) {
# calculate the polynomial term
y <- y + (c * (x ^ i))
i <- i  + 1
}
Y <- append(Y, y)
}
return(Y)
}
Y <- poly_eval(X, C)
ll <- as.integer(readline('Enter lower limit: '))
up <- as.integer(readline('Enter upper limit: '))
X = seq(ll, up, by=0.1)
Y <- poly_eval(X, C); Y
# Solution (c):
plot(X, Y)
plot_fun <- function(X, Y){
color <- readline('Enter color: ')
line_style <- as.integer(readline('Enter line style: '))
titles <- readline('Enter title of the graph: ')
plot(X, Y, col = color, main = titles, lty = line_style)
}
plot_fun(X, Y)
# set sample size
n <- 100
# init X
X_calculation <- function(n){
return(rnorm(n, mean = 0, sd = 1))
}
X <- X_calculation(n); X
# init error term
sigma2 <- 0.49
error_calculation <- function(n, sigma2){
return(rnorm(n, mean = 0, sd = sqrt(sigma2)))
}
e <- error_calculation(n, sigma2); e
# chose b0 and b1
b0 <- 10
b1 <- 0.8
# calculate value of Y
Y_calculation <- function(b0, b1, X, e){
return(b0 + (b1 * X) + e)
}
reg_func <- function(X, b0, b1, e){
Y <- Y_calculation(b0, b1, X, e)
# draw X, Y in point cloud
plot(Y ~ X, main='Point cloud of X and Y')
# linear regression model
ll_model <- lm(Y ~ X)
coef <- ll_model$coefficients
print(coef)
abline(ll_model, col='seagreen', lwd = 3)
abline(b0, b1, col='darkorange2', lwd=3)
legend("topleft", legend = c("Estimated", "True"), col = c("seagreen", "darkorange2"),
lty = 1, lwd=2)
}
reg_func(X, b0, b1, e)
tuning_n_and_sigma <- function(n, sigma2, b0, b1){
X <- X_calculation(n)
e <- error_calculation(n, sigma2)
reg_func(X, b0, b1, e)
}
tuning_n_and_sigma(n = 100, sigma2 = 0.49, b0, b1)
tuning_n_and_sigma(n = 50, sigma2 = 0.25, b0, b1)
tuning_n_and_sigma(n = 10, sigma2 = 0.64, b0, b1)
tuning_n_and_sigma(n = 1000, sigma2 = 0.64, b0, b1)
tuning_n_and_sigma(n = 50, sigma2 = 0.25, b0, b1)
tuning_n_and_sigma(n = 50, sigma2 = 0.25, b0, b1)
# init X
X_calculation <- function(n){
set.seed(123)
return(rnorm(n, mean = 0, sd = 1))
}
tuning_n_and_sigma(n = 50, sigma2 = 0.25, b0, b1)
tuning_n_and_sigma(n = 50, sigma2 = 0.25, b0, b1)
reg_func <- function(X, b0, b1, e){
# get value of Y
Y <- Y_calculation(b0, b1, X, e)
# make data frame
df <- data.frame(X, Y)
write.csv(df, file = "Dataset/new_data.csv", row.names = FALSE)
# draw X, Y in point cloud
plot(Y ~ X, main='Point cloud of X and Y')
# linear regression model
ll_model <- lm(Y ~ X)
coef <- ll_model$coefficients
print(coef)
abline(ll_model, col='seagreen', lwd = 3)
abline(b0, b1, col='darkorange2', lwd=3)
legend("topleft", legend = c("Estimated", "True"), col = c("seagreen", "darkorange2"),
lty = 1, lwd=2)
}
tuning_n_and_sigma(n = 50, sigma2 = 0.25, b0, b1)
tuning_n_and_sigma(n = 50, sigma2 = 0.25, b0, b1)
# Preparations
rm(list = ls(all.names = TRUE))
# making data frame
df <- data.frame(price, sales)
# print summary
str(df)
sales <- c(1585, 1819, 1647, 1496, 921, 1278, 1810, 1987, 1612, 1413)
price <- c(12.50, 10.00, 9.95, 11.50, 12.00, 10.00, 8.00, 9.00, 9.50, 12.50)
# making data frame
df <- data.frame(price, sales)
# print summary
str(df)
# Solution (a):
plot(df)
# Solution (b):
lr_model <- lm(df$sales ~ df$price)
summary(lr_model)$coefficient
abline(lr_model, col='seagreen', lwd = 2)
# Solution (c):
r_xy <- cor(df$sales, df$price); r_xy # -0.6172626
b1_hat <- -121.5887
sx <- sd(df$price); sx
sy <- sd(df$sales); sy
new_data <- b1_hat * (sx / sy); new_data # -0.6172626
b0_hat = 2832.8734
sales_13 <- b0_hat + (b1_hat * 13); sales_13
# I used Bangladeshi Taka
# Where 1 EUR = 115.662 BDT
price_bdt <- c(12.50, 10.00, 9.95, 11.50, 12.00, 10.00, 8.00, 9.00, 9.50, 12.50) * 115.662
price_bdt
# change layout for drawing multiple plot
par(mfrow = c(2, 1))
# draw original figure
plot(df, main = 'Point Cloud of Sales and Price (EUR)', ylab = 'Price (EUR)')
abline(lr_model, col='seagreen', lwd = 2)
# draw with converted price
df_bdt <- data.frame(price_bdt, sales)
# draw original figure
plot(df, main = 'Point Cloud of Sales and Price (EUR)', xlab = 'Price (EUR)')
# change layout for drawing multiple plot
par(mfrow = c(2, 1))
# draw original figure
plot(df, main = 'Point Cloud of Sales and Price (EUR)', xlab = 'Price (EUR)')
abline(lr_model, col='seagreen', lwd = 2)
# draw with converted price
df_bdt <- data.frame(price_bdt, sales)
plot(df_bdt, main = 'Point Cloud of Sales and Price (BDT)', xlab = 'Price(BDT)')
# model with converted data
lr_model_bdt <- lm(df_bdt$sales ~ df_bdt$price_bdt)
abline(lr_model_bdt, col='seagreen', lwd = 2)
rxy_bdt <- cor(df_bdt$sales, df_bdt$price_bdt); rxy_bdt     # -0.6172626
r2_bdt <- summary(lr_model_bdt)$r.squared; r2_bdt           # 0.3810132
r2_original <- summary(lr_model)$r.squared; r2_original     # 0.3810132
# reset the plotting window again
par(mfrow = c(1, 1))
library(lubridate)
dat <- today()
dat
class(dat)
dat <- now()
dat
class(dat)
str(dat)
dat
classof(dat)
class(dat)
quat_1_sales <- 35657.98
quat_2_sales <- 43810.55
miyear_sales <- quat_1_sales + quat_2_sales
midyear_sales <- quat_1_sales + quat_2_sales
mid
midyear_sales
# Preparations
rm(list = ls(all.names = TRUE))
quat_1_sales <- 35657.98
# Assignment operator example
quat_1_sales <- 35657.98
quat_2_sales <- 43810.55
# Artimetic operator example
midyear_sales <- quat_1_sales + quat_2_sales
midyear_sales
year_end_sales <- 2 * midyear_sales
year_end_sales <- 2 * midyear_sales; year_end_sales
# Preparations
rm(list = ls(all.names = TRUE))
source("C:/Users/DELL/Desktop/MyLearning/google_data_analyst_7/R Scripts/W2_Script_1_R_Fundamentals.R")
# Preparations
rm(list = ls(all.names = TRUE))
data("ToothGrowth")
# load the data
data("ToothGrowth")
# view it
View(ToothGrowth)
# load dplyr package
library(dplyr)
filtered_tg <- filter(ToothGrowth, dose==0.5)
View(filtered_tg)
arrange(filtered_tg, len)
filtered_toothgrowh <- ToothGrowth %>%
filter(dose == 0.5) %>%
arrange(len)
filtered_toothgrowh
filtered_toothgrowh
filtered_toothgrowh <- ToothGrowth %>%
filter(dose == 0.5) %>%
arrange(len)
filtered_toothgrowh
# pipe operation summarize
sum_df <- ToothGrowth %>%
filter(dose == 0.5) %>%
group_by(supp) %>%
summarise(mean_len = mean(len, na.rm = T), .group = "drop")
sum_df
# Preparations
rm(list = ls(all.names = TRUE))
# loading data
library(ggplot2)
data("diamonds")
# view the data
View(diamonds)
# first 6 rows
head(diamonds)
# structure of the dataframe
str(diamonds)
# only columns names
colnames(diamonds)
library(tidyverse)
# change the name of the data frame
mutate(diamonds, carat_2 = carat * 100)
# Preparations
rm(list = ls(all.names = TRUE))
# install here packgae
install.packages("here", dep=T)
# load here
library(here)
# install janitor
install.packages("janitor")
# load janitor
library(janitor)
library(dplyr)
# load penguin dataset
library(palmerpenguins)
# get summary of the datasets
skim_without_charts(penguins)
?skim_without_charts()
update.packages("skimr")
# get summary of the datasets
skim_without_charts(penguins)
update.packages("skimr")
# get summary of the datasets
str(penguins)
# first 6 rows od the data
head(penguins)
# only see a column of the data set
penguins %>%  select(specise)
# only see a column of the data set
penguins %>%
select(specise)
# only see a column of the data set
penguins %>%
select(species)
penguins %>%
select(- species)
# change the columns names
penguins %>%
rename(island_new=island)
# rename all columns name to a specific format
rename(penguins, toupper())
# rename all columns name to a specific format
rename(penguins, toupper)
# rename all columns name to a specific format
rename_with(penguins, toupper)
rename_with(penguins, tolower)
# load tidyverse
library(tidyverse)
penguins %>%  arrange(bill_length_mm)
# if we want to sort them in descending order
penguins %>% arrange(-bill_depth_mm)
# if we want to sort them in descending order
penguins %>% arrange(-bill_length_mm)
# store the arrangement into different dataframe
penguins2 <- penguins %>% arrange(-bill_length_mm)
head(penguins2)
# get the avg. length of the penguin grouped them with island
penguins %>%
group_by(islands) %>%
drop_na() %>%
summarise(mean_bill_len = mean(bill_length_mm))
# get the avg. length of the penguin grouped them with island
penguins %>%
group_by(island) %>%
drop_na() %>%
summarise(mean_bill_len = mean(bill_length_mm))
# get maximum bill length of each island
penguins %>%
group_by(island) %>%
summarise(max_bill_len = max(bill_length_mm))
# get maximum bill length of each island
penguins %>%
group_by(island) %>%
summarise(max_bill_len = max(bill_length_mm, na.rm = "drop"))
# summarize the island and species columns
penguins %>%
group_by(species, island) %>%
drop_na() %>%
summarise(max_bill = max(bill_length_mm), min_bill = min(bill_length_mm))
id <- c(1:10)
name <- c("John Mendes", "Rob Stewart", "Rachel Abrahamson", "Christy Hickman", "Johnson Harper",
"Candace Miller", "Carlson Landy", "Pansy Jordan", "Darius Berry", "Claudia Garcia")
job_title <- c("Professional", "Programmer", "Management", "Clerical", "Developer", "Programmer",
"Management", "Clerical", "Developer", "Programmer")
employee <- data.frame(id, name, job_title)
head(employee)
separate(employee, name, into = c('first_name', 'last_name'), sep = ' ')
# unite multiple columns to one
unite(employee, 'name', first_name, last_name)
# separate one column to multiple columns
emplye2 <- separate(employee, name, into = c('first_name', 'last_name'), sep = ' ')
# separate one column to multiple columns
employee2 <- separate(employee, name, into = c('first_name', 'last_name'), sep = ' ')
employee2
# unite multiple columns to one
unite(employee2, 'name', first_name, last_name)
penguins %>%
arrange(bill_length_mm)
penguins %>% arrange(bill_length_mm)
# install and load Tmisc package
install.packages('Tmisc', dep = T)
library(Tmisc)
# load quartet data
data("quartet")
# View the data
View(quartet)
# find the summary of each group
quartet %>%
group_by(set) %>%
summarise(mean_x = mean(x), sx = sd(x), mean_y = mean(y), sy = sd(y), rxy = cor(x, y))
# plot the data
ggplot(quartet, aes(x, y)) + geom_smooth(method = lm, se=FALSE) + facet_wrap(~ set)
# plot the data
ggplot(quartet, aes(x, y)) + geom_point() + geom_smooth(method = lm, se=FALSE) + facet_wrap(~ set)
# install datasauRus package
install.packages("datasauRus")
library(datasauRus)
ggplot(datasaurus_dozen, aes=(x=x, y=y, colour = dataset)) + geom_point() + theme_void() + theme(legend.position = "none") + facet_wrap(~dataset,)
ggplot(datasaurus_dozen, aes(x=x, y=y, colour = dataset)) + geom_point() + theme_void() + theme(legend.position = "none") + facet_wrap(~dataset,)
+ theme_void() + theme(legend.position = "none") + facet_wrap(~dataset,)
+ theme_void() + theme(legend.position = "none") + facet_wrap(~dataset,)
+ theme_void() + theme(legend.position = "none") + facet_wrap(~dataset,)
+ theme_void() + theme(legend.position = "none") + facet_wrap(~dataset,)
ggplot(datasaurus_dozen, aes(x=x, y=y, colour = dataset)) + geom_point() + theme_void() + theme(legend.position = "none") + facet_wrap(~dataset, ncol = 3)
+ facet_wrap(~dataset, ncol = 3)
+ facet_wrap(~dataset, ncol = 3)
ggplot(datasaurus_dozen, aes(x=x, y=y, colour = dataset)) + geom_point() + theme_void() + theme(
legend.position = "none") + facet_wrap(~dataset, ncol = 3)
# install and load SimDesign package
install.packages("SimDesign", dep = T)
library(SimDesign)
# assign some actual temperature data
actual_temp <- c(68.3, 70, 72.4, 71, 67, 70)
# Preparations
rm(list = ls(all.names = TRUE))
library(SimDesign)
# assign some actual temperature data
actual_temp <- c(68.3, 70, 72.4, 71, 67, 70)
predicted_temp <- c(67.9, 69, 71.5, 70, 67, 69)
bias(actual_temp, predicted_temp)
# another example with sales data
actual_sales <- c(150, 203, 137, 247, 116, 287)
predictd_sales <- c(200, 300, 150, 250, 150, 300)
bias(actual_sales, predictd_sales)
data("ToothGrowth")
str(ToothGrowth)
glimpse("ToothGrowth")
head(ToothGrowth)
ToothGrowth
arrange(ToothGrowth, len)
penguins %>% drop_na() %>%  group_by(species) %>% summarise(min = min(bill_depth_mm))
# Preparations
rm(list = ls(all.names = TRUE))
